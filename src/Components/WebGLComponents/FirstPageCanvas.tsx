/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/
import * as THREE from 'three';
import React, { useEffect, useRef, useState } from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import { gsap } from 'gsap';
import { useCallback } from 'react';
import { appState } from '../../store';
import { TextTioms } from './TextTioms';

export const FirstPageCanvas = (props) => {

  const material = new THREE.MeshStandardMaterial({
    color: 0xff0000,
    side: THREE.FrontSide,
    emissive: 0x800000,
    emissiveIntensity: 1
  })


  //First anim
  const group = useRef();
  const { nodes, animations } = useGLTF("./triangleC.glb");
  const { nodes:nodesServ, materials } = useGLTF("./serv.glb");
  const { actions, mixer } = useAnimations(animations, group);

  //Second anim
  const [firstAnimEnded, setFirstAnimEnded] = useState(false);
  const [togglePosition, setTogglePosition] = useState(true);
  const triangleRef = useRef();

  const [textVisibility, setTextVisibility] = useState(false);
    const [textAnimation2, setTextAnimation2] = useState(false);

  useEffect(()=>{
    props.mouseOver?setTogglePosition(false):setTogglePosition(true)
  },[props.mouseOver])

  useEffect( () => {
                console.error("Maybe here use of shader Material with vertex color and get rid of lights");
                const action = actions.CubeAction;
                
                action.play();
                action.loop = THREE.LoopOnce;
                action.clampWhenFinished = true;

                mixer.addEventListener('finished', (e) => {
                  if (e.action === action) {
                    console.log("Animation terminÃ©e");
                    setFirstAnimEnded(true);
                  }
                });

                return() => mixer.removeEventListener('finished');
                            
              },[])

    
        const endOfAllAnimation = useCallback(()=>{
          console.log("FIN DE LA PREMIERE ANIMATION DE LOGO")
          appState.introAlreadySee = true;
        })

        const animation2 = useCallback(() => {
          setTimeout(() => {
            setTogglePosition(true);
            setTextAnimation2(true);
            if(triangleRef.current){
              gsap.to(triangleRef.current.position,{ duration: 0.5, x:-0.22, y: -0.29, ease:"power2.out" });
              gsap.to(triangleRef.current.rotation,{ duration: 0.5, x:0, y: 0, z: -0.35, ease:"power2.out" });
              gsap.to(triangleRef.current.scale,{ duration: 0.5, x:0.3, y:0.3, z:0.3, ease:"power2.out", onComplete:endOfAllAnimation});
            }

          }, 1000);
        })
              
  useEffect(()=> {
                  if(firstAnimEnded){
                                    setTextVisibility(true);
                                    if(triangleRef.current){
                                          gsap.to(triangleRef.current.position,{ duration: 0.5, y: -0.55, ease:"power2.out", onComplete:()=>{setTogglePosition(false);animation2()}});
                                      }  
                                    }
                  },[firstAnimEnded])
useEffect(()=>{
if(nodesServ){
  console.log(nodesServ)
}
},[nodesServ])

  return (

          <group ref={group} {...props} dispose={null}>
            
            <group name="Scene">
              <mesh
                    name="Cube"
                    ref={triangleRef}
                    geometry={nodes.Cube.geometry}
                    material={material}
                    position={[-20, 20, 0]}
                    rotation={[0, 0, Math.PI / 4]}
                  />

            {textVisibility?<TextTioms togglePosition={togglePosition} animation2={textAnimation2}/>:<></>}
              </group>
            
              <group {...props} dispose={null}>
              <mesh geometry={nodesServ.Cube001.geometry} material={materials.Material} />
              <mesh geometry={nodesServ.Cube002.geometry} material={materials.Material} />
              <mesh geometry={nodesServ.Cube003.geometry} material={materials.Material} />
              <mesh geometry={nodesServ.Cube004.geometry} material={materials.Material} />
              </group>

          </group>
          
          
        );
}


useGLTF.preload("./triangleC.glb");
useGLTF.preload("./serv.glb");